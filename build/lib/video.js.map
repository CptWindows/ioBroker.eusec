{
  "version": 3,
  "sources": ["../../src/lib/video.ts"],
  "sourcesContent": ["import net from \"net\";\r\nimport path from \"path\";\r\nimport ffmpeg from \"@bropat/fluent-ffmpeg\";\r\nimport pathToFfmpeg from \"ffmpeg-static\";\r\nimport { Readable } from \"stream\";\r\nimport { StreamMetadata, AudioCodec, VideoCodec } from \"eufy-security-client\";\r\nimport { tmpdir } from \"os\";\r\nimport fse from \"fs-extra\";\r\n\r\nimport stream from \"node:stream\";\r\nimport {pipeline as streamPipeline} from \"node:stream/promises\";\r\n\r\nimport { ioBrokerLogger } from \"./log\";\r\nimport { lowestUnusedNumber } from \"./utils\";\r\n\r\nclass UniversalStream {\r\n\r\n    public url: string;\r\n    private static socks = new Set<number>();\r\n    private server: net.Server;\r\n    private sock_id: number;\r\n\r\n    constructor (namespace: string, onSocket: ((socket: net.Socket) => void) | undefined) {\r\n        let sockpath = \"\";\r\n\r\n        const unique_sock_id = lowestUnusedNumber([...UniversalStream.socks], 1);\r\n        UniversalStream.socks.add(unique_sock_id);\r\n        this.sock_id = unique_sock_id;\r\n\r\n        if (process.platform === \"win32\") {\r\n            const pipePrefix = \"\\\\\\\\.\\\\pipe\\\\\";\r\n            const pipeName = `node-webrtc.${namespace}.${unique_sock_id}.sock`;\r\n\r\n            sockpath = path.join(pipePrefix, pipeName);\r\n            this.url = sockpath;\r\n        }\r\n        else {\r\n            const pipeName = `${namespace}.${unique_sock_id}.sock`;\r\n            sockpath = path.join(tmpdir(), pipeName);\r\n            this.url = \"unix:\" + sockpath;\r\n\r\n            try {\r\n                if (fse.existsSync(sockpath))\r\n                    fse.unlinkSync(sockpath);\r\n            } catch(error) {\r\n            }\r\n        }\r\n\r\n        this.server = net.createServer(onSocket);\r\n        this.server.listen(sockpath);\r\n        this.server.on(\"error\", () => {});\r\n    }\r\n\r\n    public close(): void {\r\n        if (this.server)\r\n            this.server.close();\r\n        UniversalStream.socks.delete(this.sock_id);\r\n    }\r\n\r\n}\r\n\r\nexport const StreamInput = function(namespace: string, stream: NodeJS.ReadableStream): UniversalStream {\r\n    return new UniversalStream(namespace, (socket: net.Socket) => stream.pipe(socket, { end: true }))\r\n}\r\n\r\nexport const StreamOutput = function(namespace: string, stream: NodeJS.WritableStream): UniversalStream {\r\n    return new UniversalStream(namespace, (socket: net.Socket) => socket.pipe(stream, { end: true }))\r\n}\r\n\r\nexport const ffmpegPreviewImage = (config: ioBroker.AdapterConfig, input:string, output: string, log: ioBrokerLogger, skip_seconds = 2.0): Promise<void> => {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            if (pathToFfmpeg) {\r\n                ffmpeg.setFfmpegPath(pathToFfmpeg);\r\n\r\n                ffmpeg()\r\n                    .withProcessOptions({\r\n                        detached: true\r\n                    })\r\n                    .addOptions([\r\n                        `-ss ${skip_seconds}`,\r\n                        \"-frames:v 1\"\r\n                    ])\r\n                    .input(input)\r\n                    .inputFormat(\"hls\")\r\n                    .outputFormat(\"image2\")\r\n                    .output(output)\r\n                    .on(\"error\", function(err, stdout, stderr) {\r\n                        log.error(`ffmpegPreviewImage(): An error occurred: ${err.message}`);\r\n                        log.error(`ffmpegPreviewImage(): ffmpeg output:\\n${stdout}`);\r\n                        log.error(`ffmpegPreviewImage(): ffmpeg stderr:\\n${stderr}`);\r\n                        reject(err);\r\n                    })\r\n                    .on(\"end\", () => {\r\n                        log.debug(\"ffmpegPreviewImage(): Preview image generated!\");\r\n                        resolve();\r\n                    })\r\n                    .run();\r\n            } else {\r\n                reject(new Error(\"ffmpeg binary not found\"));\r\n            }\r\n        } catch (error) {\r\n            log.error(`ffmpegPreviewImage(): Error: ${error}`);\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\nexport const ffmpegStreamToHls = (config: ioBroker.AdapterConfig, namespace: string, metadata: StreamMetadata, videoStream: Readable, audioStream: Readable, output: string, log: ioBrokerLogger): Promise<void> => {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            if (pathToFfmpeg) {\r\n                ffmpeg.setFfmpegPath(pathToFfmpeg);\r\n\r\n                videoStream.on(\"error\", (error) => {\r\n                    log.error(\"ffmpegStreamToHls(): Videostream Error\", error);\r\n                });\r\n\r\n                audioStream.on(\"error\", (error) => {\r\n                    log.error(\"ffmpegStreamToHls(): Audiostream Error\", error);\r\n                });\r\n\r\n                const uVideoStream = StreamInput(namespace, videoStream);\r\n                const uAudioStream = StreamInput(namespace, audioStream);\r\n\r\n                let videoFormat = \"h264\";\r\n                let audioFormat = \"\";\r\n                const options: string[] = [\r\n                    \"-hls_init_time 0\",\r\n                    \"-hls_time 2\",\r\n                    \"-hls_segment_type mpegts\",\r\n                    //\"-start_number 1\",\r\n                    \"-sc_threshold 0\",\r\n                    `-g ${metadata.videoFPS}`,\r\n                    \"-fflags genpts+nobuffer+flush_packets\",\r\n                    //\"-flush_packets 1\",\r\n                    \"-hls_playlist_type event\"\r\n                    //\"-hls_flags split_by_time\"\r\n                ];\r\n\r\n                switch(metadata.videoCodec) {\r\n                    case VideoCodec.H264:\r\n                        videoFormat = \"h264\";\r\n                        break;\r\n                    case VideoCodec.H265:\r\n                        videoFormat = \"hevc\";\r\n                        break;\r\n                }\r\n\r\n                switch(metadata.audioCodec) {\r\n                    case AudioCodec.AAC:\r\n                        audioFormat = \"aac\";\r\n                        break;\r\n                }\r\n\r\n                const command = ffmpeg()\r\n                    .withProcessOptions({\r\n                        detached: true\r\n                    })\r\n                    .input(uVideoStream.url)\r\n                    .inputFormat(videoFormat)\r\n                    .inputFps(metadata.videoFPS);\r\n                if (audioFormat !== \"\") {\r\n                    command.input(uAudioStream.url)\r\n                        .inputFormat(audioFormat)\r\n                        .videoCodec(\"copy\")\r\n                        .audioCodec(\"copy\");\r\n                    options.push(\"-absf aac_adtstoasc\");\r\n                } else {\r\n                    log.warn(`ffmpegStreamToHls(): Not support audio codec or unknown audio codec (${AudioCodec[metadata.audioCodec]})`);\r\n                }\r\n                command.output(output)\r\n                    .addOptions(options)\r\n                    .on(\"error\", function(err, stdout, stderr) {\r\n                        log.error(`ffmpegStreamToHls(): An error occurred: ${err.message}`);\r\n                        log.error(`ffmpegStreamToHls(): ffmpeg output:\\n${stdout}`);\r\n                        log.error(`ffmpegStreamToHls(): ffmpeg stderr:\\n${stderr}`);\r\n                        uVideoStream.close();\r\n                        uAudioStream.close();\r\n                        reject(err);\r\n                    })\r\n                    .on(\"end\", () => {\r\n                        log.debug(\"ffmpegStreamToHls(): Processing finished!\");\r\n                        uVideoStream.close();\r\n                        uAudioStream.close();\r\n                        resolve();\r\n                    });\r\n                command.run();\r\n            } else {\r\n                reject(new Error(\"ffmpeg binary not found\"));\r\n            }\r\n        } catch (error) {\r\n            log.error(`ffmpegStreamToHls(): Error: ${error}`);\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\nexport const ffmpegStreamToGo2rtc = (config: ioBroker.AdapterConfig, namespace: string, camera: string, metadata: StreamMetadata, videoStream: Readable, audioStream: Readable, log: ioBrokerLogger): Promise<void> => {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            if (pathToFfmpeg) {\r\n                ffmpeg.setFfmpegPath(pathToFfmpeg);\r\n\r\n                videoStream.on(\"error\", (error) => {\r\n                    log.error(\"ffmpegStreamToGo2rtc(): Videostream Error\", error);\r\n                });\r\n\r\n                audioStream.on(\"error\", (error) => {\r\n                    log.error(\"ffmpegStreamToGo2rtc(): Audiostream Error\", error);\r\n                });\r\n\r\n                //TODO: For debugging purposes\r\n                /*const outputVFile = path.resolve(__dirname, \"../../video-stream.dump\");\r\n                videoStream.pipe(fse.createWriteStream(outputVFile)).on(\"finish\", () => {\r\n                    log.debug(\"videoStream dump finished!\");\r\n                    log.info(\"Manually test the output by running# ffplay output/video-stream.dump\");\r\n                });\r\n                const outputAFile = path.resolve(__dirname, \"../../audio-stream.dump\");\r\n                audioStream.pipe(fse.createWriteStream(outputAFile)).on(\"finish\", () => {\r\n                    log.debug(\"audioStream dump finished!\");\r\n                    log.info(\"Manually test the output by running# ffplay output/audio-stream.dump\");\r\n                });*/\r\n\r\n                const uVideoStream = StreamInput(namespace, videoStream);\r\n                const uAudioStream = StreamInput(namespace, audioStream);\r\n\r\n                let videoFormat = \"h264\";\r\n                let audioFormat = \"\";\r\n                const options: string[] = [\r\n                    \"-rtsp_transport tcp\",\r\n                    \"-sc_threshold 0\",\r\n                    \"-fflags genpts+nobuffer+flush_packets\",\r\n                    //\"-rtpflags latm\",\r\n                ];\r\n\r\n                switch(metadata.videoCodec) {\r\n                    case VideoCodec.H264:\r\n                        videoFormat = \"h264\";\r\n                        break;\r\n                    case VideoCodec.H265:\r\n                        videoFormat = \"hevc\";\r\n                        break;\r\n                }\r\n\r\n                switch(metadata.audioCodec) {\r\n                    case AudioCodec.AAC:\r\n                        audioFormat = \"aac\";\r\n                        break;\r\n                }\r\n\r\n                const command = ffmpeg()\r\n                    .withProcessOptions({\r\n                        detached: true\r\n                    })\r\n                    .input(uVideoStream.url)\r\n                    .inputFormat(videoFormat);\r\n                if (metadata.videoFPS > 0 ) {\r\n                    options.push(`-g ${metadata.videoFPS}`);\r\n                    command.inputFps(metadata.videoFPS);\r\n                }\r\n                command.videoCodec(\"copy\");\r\n                if (audioFormat !== \"\") {\r\n                    command.input(uAudioStream.url)\r\n                        .inputFormat(audioFormat)\r\n                        //.audioCodec(\"copy\");\r\n                        //.audioCodec(\"aac\");\r\n                        .audioCodec(\"opus\");\r\n                } else {\r\n                    log.warn(`ffmpegStreamToGo2rtc(): Not support audio codec or unknown audio codec (${AudioCodec[metadata.audioCodec]})`);\r\n                }\r\n                command.output(`rtsp://localhost:${config.go2rtc_rtsp_port}/${camera}`)\r\n                    .outputFormat(\"rtsp\")\r\n                    .addOptions(options)\r\n                    .on(\"start\", (commandline) => {\r\n                        log.debug(`ffmpegStreamToGo2rtc(): commandline: ${commandline}`);\r\n                    })\r\n                    .on(\"error\", function(err, stdout, stderr) {\r\n                        log.error(`ffmpegStreamToGo2rtc(): An error occurred: ${err.message}`);\r\n                        log.error(`ffmpegStreamToGo2rtc(): ffmpeg output:\\n${stdout}`);\r\n                        log.error(`ffmpegStreamToGo2rtc(): ffmpeg stderr:\\n${stderr}`);\r\n                        uVideoStream.close();\r\n                        uAudioStream.close();\r\n                        reject(err);\r\n                    })\r\n                    .on(\"end\", () => {\r\n                        log.debug(\"ffmpegStreamToGo2rtc(): Processing finished!\");\r\n                        uVideoStream.close();\r\n                        uAudioStream.close();\r\n                        resolve();\r\n                    });\r\n                command.run();\r\n            } else {\r\n                reject(new Error(\"ffmpeg binary not found\"));\r\n            }\r\n        } catch (error) {\r\n            log.error(`ffmpegStreamToGo2rtc(): Error: ${error}`);\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\nexport const streamToGo2rtc = async (camera: string, videoStream: Readable, audioStream: Readable, log: ioBrokerLogger, config: ioBroker.AdapterConfig, namespace: string, metadata: StreamMetadata): Promise<Array<PromiseSettledResult<void>>> => {\r\n    const { default: got } = await import(\"got\");\r\n    videoStream.on(\"error\", (error) => {\r\n        log.error(\"streamToGo2rtc(): Videostream Error\", error);\r\n    });\r\n\r\n    audioStream.on(\"error\", (error) => {\r\n        log.error(\"streamToGo2rtc(): Audiostream Error\", error);\r\n    });\r\n    return Promise.allSettled([\r\n        streamPipeline(\r\n            videoStream,\r\n            got.stream.post(`http://localhost:1984/api/stream?dst=${camera}`),\r\n            new stream.PassThrough()\r\n        ),\r\n        //TODO: Tested with go2rtc 1.8.4 but not working - no audio; When the error in go2rtc is fixed, reactivate this part and remove the ffmpeg part\r\n        /*streamPipeline(\r\n            audioStream,\r\n            got.stream.post(`http://localhost:1984/api/stream?dst=${camera}#audio=opus`),\r\n            //got.stream.post(`http://localhost:1984/api/stream?dst=${camera}`),\r\n            new stream.PassThrough()\r\n        )*/\r\n        new Promise<void>((resolve, reject) => {\r\n            try {\r\n                if (pathToFfmpeg) {\r\n                    ffmpeg.setFfmpegPath(pathToFfmpeg);\r\n\r\n                    const uAudioStream = StreamInput(namespace, audioStream);\r\n\r\n                    let audioFormat = \"\";\r\n                    const options: string[] = [\r\n                        \"-rtsp_transport tcp\",\r\n                        \"-sc_threshold 0\",\r\n                        \"-fflags genpts+nobuffer+flush_packets\",\r\n                        //\"-rtpflags latm\",\r\n                    ];\r\n\r\n                    switch(metadata.audioCodec) {\r\n                        case AudioCodec.AAC:\r\n                            audioFormat = \"aac\";\r\n                            break;\r\n                    }\r\n\r\n                    const command = ffmpeg()\r\n                        .withProcessOptions({\r\n                            detached: true\r\n                        });\r\n\r\n                    if (audioFormat !== \"\") {\r\n                        command.input(uAudioStream.url)\r\n                            .inputFormat(audioFormat)\r\n                            //.audioCodec(\"copy\");\r\n                            //.audioCodec(\"aac\");\r\n                            .audioCodec(\"opus\");\r\n                    } else {\r\n                        log.warn(`streamToGo2rtc(): ffmpeg - Not support audio codec or unknown audio codec (${AudioCodec[metadata.audioCodec]})`);\r\n                    }\r\n                    command.output(`rtsp://localhost:${config.go2rtc_rtsp_port}/${camera}`)\r\n                        .outputFormat(\"rtsp\")\r\n                        .addOptions(options)\r\n                        .on(\"start\", (commandline) => {\r\n                            log.debug(`streamToGo2rtc(): ffmpeg - commandline: ${commandline}`);\r\n                        })\r\n                        .on(\"error\", function(err, stdout, stderr) {\r\n                            log.error(`streamToGo2rtc(): ffmpeg - An error occurred: ${err.message}`);\r\n                            log.error(`streamToGo2rtc(): ffmpeg output:\\n${stdout}`);\r\n                            log.error(`streamToGo2rtc(): ffmpeg stderr:\\n${stderr}`);\r\n                            uAudioStream.close();\r\n                            reject(err);\r\n                        })\r\n                        .on(\"end\", () => {\r\n                            log.debug(\"streamToGo2rtc(): Processing finished!\");\r\n                            uAudioStream.close();\r\n                            resolve();\r\n                        });\r\n                    command.run();\r\n                } else {\r\n                    reject(new Error(\"ffmpeg binary not found\"));\r\n                }\r\n            } catch (error) {\r\n                log.error(`streamToGo2rtc(): Audio Error: ${error}`);\r\n                reject(error);\r\n            }\r\n        })\r\n        /*new Promise<void>((resolve, reject) => {\r\n            try {\r\n                if (pathToFfmpeg) {\r\n                    ffmpeg.setFfmpegPath(pathToFfmpeg);\r\n\r\n                    const uAudioStream = StreamInput(namespace, audioStream);\r\n\r\n                    let audioFormat = \"\";\r\n                    const options: string[] = [\r\n                        //\"-rtsp_transport tcp\",\r\n                        \"-sc_threshold 0\",\r\n                        \"-fflags genpts+nobuffer+flush_packets\",\r\n                        //\"-rtpflags latm\",\r\n                    ];\r\n\r\n                    switch(metadata.audioCodec) {\r\n                        case AudioCodec.AAC:\r\n                            audioFormat = \"aac\";\r\n                            break;\r\n                    }\r\n\r\n                    const command = ffmpeg()\r\n                        .withProcessOptions({\r\n                            detached: true\r\n                        });\r\n\r\n                    if (audioFormat !== \"\") {\r\n                        command.input(uAudioStream.url)\r\n                            .format(\"adts\")\r\n                            //.inputFormat(audioFormat)\r\n                            .audioCodec(\"aac\");\r\n                        //.audioCodec(\"aac\");\r\n                        //.audioCodec(\"opus\");\r\n                    } else {\r\n                        log.warn(`streamToGo2rtc(): ffmpeg - Not support audio codec or unknown audio codec (${AudioCodec[metadata.audioCodec]})`);\r\n                    }\r\n                    //command.output(`rtsp://localhost:${config.go2rtc_rtsp_port}/${camera}`)\r\n                    command.output(`http://localhost:1984/api/stream?dst=${camera}`)\r\n                        //.outputFormat(\"rtsp\")\r\n                        .addOptions(options)\r\n                        .on(\"start\", (commandline) => {\r\n                            log.debug(`streamToGo2rtc(): ffmpeg - commandline: ${commandline}`);\r\n                        })\r\n                        .on(\"error\", function(err, stdout, stderr) {\r\n                            log.error(`streamToGo2rtc(): ffmpeg - An error occurred: ${err.message}`);\r\n                            log.error(`streamToGo2rtc(): ffmpeg output:\\n${stdout}`);\r\n                            log.error(`streamToGo2rtc(): ffmpeg stderr:\\n${stderr}`);\r\n                            uAudioStream.close();\r\n                            reject(err);\r\n                        })\r\n                        .on(\"end\", () => {\r\n                            log.debug(\"streamToGo2rtc(): Processing finished!\");\r\n                            uAudioStream.close();\r\n                            resolve();\r\n                        });\r\n                    command.run();\r\n                } else {\r\n                    reject(new Error(\"ffmpeg binary not found\"));\r\n                }\r\n            } catch (error) {\r\n                log.error(`streamToGo2rtc(): Audio Error: ${error}`);\r\n                reject(error);\r\n            }\r\n        })*/\r\n    ]);\r\n}"],
  "mappings": "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",
  "names": ["path", "fse", "net", "stream", "pathToFfmpeg", "ffmpeg", "streamPipeline"]
}
