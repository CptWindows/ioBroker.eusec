{
  "version": 3,
  "sources": ["../../src/lib/video.ts"],
  "sourcesContent": ["import net from \"net\";\r\nimport path from \"path\";\r\nimport ffmpeg from \"@bropat/fluent-ffmpeg\";\r\nimport pathToFfmpeg from \"ffmpeg-static\";\r\nimport { Readable } from \"stream\";\r\nimport { StreamMetadata, AudioCodec, VideoCodec } from \"eufy-security-client\";\r\nimport { tmpdir } from \"os\";\r\nimport fse from \"fs-extra\";\r\n\r\nimport { ioBrokerLogger } from \"./log\";\r\nimport { lowestUnusedNumber } from \"./utils\";\r\n\r\nclass UniversalStream {\r\n\r\n    public url: string;\r\n    private static socks = new Set<number>();\r\n    private server: net.Server;\r\n    private sock_id: number;\r\n\r\n    constructor (namespace: string, onSocket: ((socket: net.Socket) => void) | undefined) {\r\n        let sockpath = \"\";\r\n\r\n        const unique_sock_id = lowestUnusedNumber([...UniversalStream.socks], 1);\r\n        UniversalStream.socks.add(unique_sock_id);\r\n        this.sock_id = unique_sock_id;\r\n\r\n        if (process.platform === \"win32\") {\r\n            const pipePrefix = \"\\\\\\\\.\\\\pipe\\\\\";\r\n            const pipeName = `node-webrtc.${namespace}.${unique_sock_id}.sock`;\r\n\r\n            sockpath = path.join(pipePrefix, pipeName);\r\n            this.url = sockpath;\r\n        }\r\n        else {\r\n            const pipeName = `${namespace}.${unique_sock_id}.sock`;\r\n            sockpath = path.join(tmpdir(), pipeName);\r\n            this.url = \"unix:\" + sockpath;\r\n\r\n            try {\r\n                if (fse.existsSync(sockpath))\r\n                    fse.unlinkSync(sockpath);\r\n            } catch(error) {\r\n            }\r\n        }\r\n\r\n        this.server = net.createServer(onSocket);\r\n        this.server.listen(sockpath);\r\n    }\r\n\r\n    public close(): void {\r\n        if (this.server)\r\n            this.server.close();\r\n        UniversalStream.socks.delete(this.sock_id);\r\n    }\r\n\r\n}\r\n\r\nexport const StreamInput = function(namespace: string, stream: NodeJS.ReadableStream): UniversalStream {\r\n    return new UniversalStream(namespace, (socket: net.Socket) => stream.pipe(socket, { end: true }))\r\n}\r\n\r\nexport const StreamOutput = function(namespace: string, stream: NodeJS.WritableStream): UniversalStream {\r\n    return new UniversalStream(namespace, (socket: net.Socket) => socket.pipe(stream, { end: true }))\r\n}\r\n\r\nexport const ffmpegPreviewImage = (config: ioBroker.AdapterConfig, input:string, output: string, log: ioBrokerLogger, skip_seconds = 2.0): Promise<void> => {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            if (pathToFfmpeg) {\r\n                ffmpeg.setFfmpegPath(pathToFfmpeg);\r\n\r\n                ffmpeg()\r\n                    .withProcessOptions({\r\n                        detached: true\r\n                    })\r\n                    .addOptions([\r\n                        `-ss ${skip_seconds}`,\r\n                        \"-frames:v 1\"\r\n                    ])\r\n                    .input(input)\r\n                    .inputFormat(\"hls\")\r\n                    .outputFormat(\"image2\")\r\n                    .output(output)\r\n                    .on(\"error\", function(err, stdout, stderr) {\r\n                        log.error(`ffmpegPreviewImage(): An error occurred: ${err.message}`);\r\n                        log.error(`ffmpegPreviewImage(): ffmpeg output:\\n${stdout}`);\r\n                        log.error(`ffmpegPreviewImage(): ffmpeg stderr:\\n${stderr}`);\r\n                        reject(err);\r\n                    })\r\n                    .on(\"end\", () => {\r\n                        log.debug(\"ffmpegPreviewImage(): Preview image generated!\");\r\n                        resolve();\r\n                    })\r\n                    .run();\r\n            } else {\r\n                reject(new Error(\"ffmpeg binary not found\"));\r\n            }\r\n        } catch (error) {\r\n            log.error(`ffmpegPreviewImage(): Error: ${error}`);\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\nexport const ffmpegStreamToHls = (config: ioBroker.AdapterConfig, namespace: string, metadata: StreamMetadata, videoStream: Readable, audioStream: Readable, output: string, log: ioBrokerLogger): Promise<void> => {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            if (pathToFfmpeg) {\r\n                ffmpeg.setFfmpegPath(pathToFfmpeg);\r\n\r\n                videoStream.on(\"error\", (error) => {\r\n                    log.error(\"ffmpegStreamToHls(): Videostream Error\", error);\r\n                });\r\n\r\n                audioStream.on(\"error\", (error) => {\r\n                    log.error(\"ffmpegStreamToHls(): Audiostream Error\", error);\r\n                });\r\n\r\n                const uVideoStream = StreamInput(namespace, videoStream);\r\n                const uAudioStream = StreamInput(namespace, audioStream);\r\n\r\n                let videoFormat = \"h264\";\r\n                let audioFormat = \"\";\r\n                const options: string[] = [\r\n                    \"-hls_init_time 0\",\r\n                    \"-hls_time 2\",\r\n                    \"-hls_segment_type mpegts\",\r\n                    //\"-start_number 1\",\r\n                    \"-sc_threshold 0\",\r\n                    `-g ${metadata.videoFPS}`,\r\n                    \"-fflags genpts+nobuffer+flush_packets\",\r\n                    //\"-flush_packets 1\",\r\n                    \"-hls_playlist_type event\"\r\n                    //\"-hls_flags split_by_time\"\r\n                ];\r\n\r\n                switch(metadata.videoCodec) {\r\n                    case VideoCodec.H264:\r\n                        videoFormat = \"h264\";\r\n                        break;\r\n                    case VideoCodec.H265:\r\n                        videoFormat = \"hevc\";\r\n                        break;\r\n                }\r\n\r\n                switch(metadata.audioCodec) {\r\n                    case AudioCodec.AAC:\r\n                        audioFormat = \"aac\";\r\n                        break;\r\n                }\r\n\r\n                const command = ffmpeg()\r\n                    .withProcessOptions({\r\n                        detached: true\r\n                    })\r\n                    .input(uVideoStream.url)\r\n                    .inputFormat(videoFormat)\r\n                    .inputFps(metadata.videoFPS);\r\n                if (audioFormat !== \"\") {\r\n                    command.input(uAudioStream.url)\r\n                        .inputFormat(audioFormat)\r\n                        .videoCodec(\"copy\")\r\n                        .audioCodec(\"copy\");\r\n                    options.push(\"-absf aac_adtstoasc\");\r\n                } else {\r\n                    log.warn(`ffmpegStreamToHls(): Not support audio codec or unknown audio codec (${AudioCodec[metadata.audioCodec]})`);\r\n                }\r\n                command.output(output)\r\n                    .addOptions(options)\r\n                    .on(\"error\", function(err, stdout, stderr) {\r\n                        log.error(`ffmpegStreamToHls(): An error occurred: ${err.message}`);\r\n                        log.error(`ffmpegStreamToHls(): ffmpeg output:\\n${stdout}`);\r\n                        log.error(`ffmpegStreamToHls(): ffmpeg stderr:\\n${stderr}`);\r\n                        uVideoStream.close();\r\n                        uAudioStream.close();\r\n                        reject(err);\r\n                    })\r\n                    .on(\"end\", () => {\r\n                        log.debug(\"ffmpegStreamToHls(): Processing finished!\");\r\n                        uVideoStream.close();\r\n                        uAudioStream.close();\r\n                        resolve();\r\n                    });\r\n                command.run();\r\n            } else {\r\n                reject(new Error(\"ffmpeg binary not found\"));\r\n            }\r\n        } catch (error) {\r\n            log.error(`ffmpegStreamToHls(): Error: ${error}`);\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\nexport const ffmpegStreamToGo2rtc = (config: ioBroker.AdapterConfig, namespace: string, camera: string, metadata: StreamMetadata, videoStream: Readable, audioStream: Readable, log: ioBrokerLogger): Promise<void> => {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            if (pathToFfmpeg) {\r\n                ffmpeg.setFfmpegPath(pathToFfmpeg);\r\n\r\n                log.warn(\"ffmpegStreamToGo2rtc(): Started\");\r\n\r\n                videoStream.on(\"error\", (error) => {\r\n                    log.error(\"ffmpegStreamToGo2rtc(): Videostream Error\", error);\r\n                });\r\n\r\n                audioStream.on(\"error\", (error) => {\r\n                    log.error(\"ffmpegStreamToGo2rtc(): Audiostream Error\", error);\r\n                });\r\n\r\n                //TODO: For debugging purposes\r\n                /*const outputFile = path.resolve(__dirname, \"../../test-stream.dump\");\r\n                videoStream.pipe(fse.createWriteStream(outputFile)).on(\"finish\", () => {\r\n                    log.debug(\"videoStream dump finished!\");\r\n                    log.info(\"Manually test the output by running# ffplay output/test-stream.dump\");\r\n                });*/\r\n\r\n                const uVideoStream = StreamInput(namespace, videoStream);\r\n                const uAudioStream = StreamInput(namespace, audioStream);\r\n\r\n                let videoFormat = \"h264\";\r\n                let audioFormat = \"\";\r\n                const options: string[] = [\r\n                    \"-rtsp_transport tcp\",\r\n                    \"-sc_threshold 0\",\r\n                    `-g ${metadata.videoFPS}`,\r\n                    \"-fflags genpts+nobuffer+flush_packets\",\r\n                    //\"-rtpflags latm\",\r\n                ];\r\n\r\n                switch(metadata.videoCodec) {\r\n                    case VideoCodec.H264:\r\n                        videoFormat = \"h264\";\r\n                        break;\r\n                    case VideoCodec.H265:\r\n                        videoFormat = \"hevc\";\r\n                        break;\r\n                }\r\n\r\n                switch(metadata.audioCodec) {\r\n                    case AudioCodec.AAC:\r\n                        audioFormat = \"aac\";\r\n                        break;\r\n                }\r\n\r\n                const command = ffmpeg()\r\n                    .withProcessOptions({\r\n                        detached: true\r\n                    })\r\n                    .input(uVideoStream.url)\r\n                    .inputFormat(videoFormat)\r\n                    .inputFps(metadata.videoFPS)\r\n                    .videoCodec(\"copy\");\r\n                if (audioFormat !== \"\") {\r\n                    command.input(uAudioStream.url)\r\n                        .inputFormat(audioFormat)\r\n                        //.audioCodec(\"copy\");\r\n                        //.audioCodec(\"aac\");\r\n                        .audioCodec(\"opus\");\r\n                } else {\r\n                    log.warn(`ffmpegStreamToGo2rtc(): Not support audio codec or unknown audio codec (${AudioCodec[metadata.audioCodec]})`);\r\n                }\r\n                command.output(`rtsp://localhost:${config.go2rtc_rtsp_port}/${camera}`)\r\n                    .outputFormat(\"rtsp\")\r\n                    .addOptions(options)\r\n                    .on(\"error\", function(err, stdout, stderr) {\r\n                        log.error(`ffmpegStreamToGo2rtc(): An error occurred: ${err.message}`);\r\n                        log.error(`ffmpegStreamToGo2rtc(): ffmpeg output:\\n${stdout}`);\r\n                        log.error(`ffmpegStreamToGo2rtc(): ffmpeg stderr:\\n${stderr}`);\r\n                        uVideoStream.close();\r\n                        uAudioStream.close();\r\n                        reject(err);\r\n                    })\r\n                    .on(\"end\", () => {\r\n                        log.debug(\"ffmpegStreamToGo2rtc(): Processing finished!\");\r\n                        uVideoStream.close();\r\n                        uAudioStream.close();\r\n                        resolve();\r\n                    });\r\n                command.run();\r\n            } else {\r\n                reject(new Error(\"ffmpeg binary not found\"));\r\n            }\r\n        } catch (error) {\r\n            log.error(`ffmpegStreamToGo2rtc(): Error: ${error}`);\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n"],
  "mappings": "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",
  "names": ["path", "fse", "net", "pathToFfmpeg", "ffmpeg"]
}
